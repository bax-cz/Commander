#include "stdafx.h"

#include "Commander.h"
#include "FictionBook2DataProvider.h"
#include "FileSystemUtils.h"
#include "NetworkUtils.h"
#include "MiscUtils.h"
#include "XmlUtils.h"
#include "ViewerTypes.h"

#include "Resources/fb2_xsl.h" /* auto-generated by embed.exe (prebuild event) */

#ifdef True        /* defined in 7-zip */
#undef True
#endif
#ifdef False       /* defined in 7-zip */
#undef False
#endif
#ifdef put_padding /* defined in putty/marshall.h */
#undef put_padding
#endif

#define FB20NS  L"http://www.gribuser.ru/xml/fictionbook/2.0"
#define FB21NS  L"http://www.gribuser.ru/xml/fictionbook/2.1"
#define XLINKNS L"http://www.w3.org/1999/xlink"

namespace Commander
{
	//
	// Constructor/destructor
	//
	CFictionBook2DataProvider::CFictionBook2DataProvider()
	{
	}

	CFictionBook2DataProvider::~CFictionBook2DataProvider()
	{
		// stop workers
		_worker.stop();
	}

	bool CFictionBook2DataProvider::readData( const std::wstring& fileName, std::shared_ptr<CPanelTab> spPanel, HWND hWndNotify )
	{
		_worker.init( [this] { return _readDataCore(); }, hWndNotify, UM_READERNOTIFY );
		_readToFile = false;

		// TODO

		return false; //_worker.start();
	}

	bool CFictionBook2DataProvider::readToFile( const std::wstring& fileName, std::shared_ptr<CPanelTab> spPanel, HWND hWndNotify )
	{
		_worker.init( [this] { return _readDataCore(); }, hWndNotify, UM_READERNOTIFY );

		_readToFile = true;
		_fileName = fileName;

		return _worker.start();
	}

	std::wstring decompressXslData()
	{
		std::string data;
		data.resize( fb2_xsl_length );
		uLongf data_len = fb2_xsl_length;

		int ret = uncompress( reinterpret_cast<Bytef*>( &data[0] ), &data_len, reinterpret_cast<const Bytef*>( fb2_xsl_data ), sizeof( fb2_xsl_data ) );

		_ASSERTE( data_len == fb2_xsl_length );

		switch( ret )
		{
		case Z_OK: // success
			break;
		case Z_MEM_ERROR:  // there was not enough memory
		case Z_BUF_ERROR:  // there was not enough room in the output buffer
		case Z_DATA_ERROR: // the input data was corrupted or incomplete
			return L"";
		}

		return StringUtils::convert2W( data );
	}

	bool extractImage( const std::wstring& fileName, const BSTR base64data, UINT dataLen )
	{
		/*std::ofstream fs( fileName, std::ios::binary );

		unsigned char *buf = new unsigned char[dataLen];
		size_t off = 0;

		for( UINT i = 0; i < dataLen; i++ )
		{
			if( base64data[i] == L'\n' )
			{
				fs << StringUtils::base64Decode( buf, off );
				off = 0;
			}
			else
				buf[off++] = static_cast<unsigned char>( base64data[i] );
		}

		fs << StringUtils::base64Decode( buf, off );

		delete[] buf;*/

		// convert BSTR (wchar) array to char array
		std::string tempstr; tempstr.resize( dataLen );

		for( UINT i = 0; i < dataLen; i++ )
			tempstr[i] = static_cast<char>( base64data[i] );

		// decode the base64-encoded data
		tempstr = StringUtils::base64Decode( reinterpret_cast<unsigned char*>( &tempstr[0] ), tempstr.length() );

		// write the decoded data to a binary file
		std::ofstream fs( fileName, std::ios::binary );
		fs << tempstr;

		return true;
	}

	std::map<std::wstring, std::wstring> extractBinaryContent( IXMLDOMDocument2 *pXMLDoc, const std::wstring& outPath )
	{
		std::map<std::wstring, std::wstring> files;

		CComPtr<IXMLDOMNodeList> pNodesList;
		pXMLDoc->selectNodes( L"/FictionBook/binary", &pNodesList );

		long len = 0;
		pNodesList->get_length( &len );

		for( long i = 0; i < len; i++ )
		{
			CComPtr<IXMLDOMNode> pNode;
			pNodesList->get_item( i, &pNode );

			auto fname = XmlUtils::getNodeAttrValue( pNode, L"id" );
			auto ftype = XmlUtils::getNodeAttrValue( pNode, L"content-type" );

			// extract only images TODO??
			if( StringUtils::startsWith( ftype, L"image" ) )
			{
				auto ext = PathUtils::getFileNameExtension( fname );
				auto id = fname;

				// construct filename from image type
				if( !StringUtils::endsWith( fname, L".jpeg" ) &&
					!StringUtils::endsWith( fname, L".jpg" ) &&
					!StringUtils::endsWith( fname, L".png" ) )
				{
					if( !ext.empty() )
					{
						PrintDebug("Unknown file extension: %ls (%ls)", ext.c_str(), ftype.c_str());
					}
					else
						fname += L"." + ftype.substr( 6 );
				}

				CComBSTR fdata;
				HRESULT hr = pNode->get_text( &fdata );

				if( SUCCEEDED( hr ) && fdata )
				{
					if( extractImage( outPath + fname, fdata, fdata.Length() ) )
						files[id] = fname;
				}
			}
		}

		return files;
	}

	bool loadFileData( const std::wstring& fileName, std::wstring& xmlData )
	{
		WIN32_FIND_DATA wfd = { 0 };
		if( FsUtils::getFileInfo( fileName, wfd ) )
		{
			auto fsize = FsUtils::getFileSize( &wfd );
			std::string fdata; fdata.resize( fsize );

			std::ifstream fs( PathUtils::getExtendedPath( fileName ), std::ios::binary );

			if( fs.is_open() )
			{
				fs.read( &fdata[0], fsize );
				StringUtils::convert2W( &fdata[0], fdata.length(), xmlData );
			}

			return true;
		}

		return false;
	}

	bool CFictionBook2DataProvider::fb2html( const std::wstring& fileNameIn, const std::wstring& fileNameOut )
	{
		CComPtr<IXMLDOMDocument2> pXMLDoc;
		HRESULT hr = CoCreateInstance( __uuidof( DOMDocument30 ), NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS( &pXMLDoc ) );

		CComPtr<IXMLDOMDocument2> pXSLDoc;
		hr = CoCreateInstance( __uuidof( DOMDocument30 ), NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS( &pXSLDoc ) );

		if( SUCCEEDED( hr ) && pXMLDoc && pXSLDoc )
		{
			VARIANT_BOOL fLoaded = VARIANT_FALSE;

			// disable validation and externals
			pXMLDoc->put_validateOnParse( VARIANT_FALSE );
			pXSLDoc->put_validateOnParse( VARIANT_FALSE );
			pXMLDoc->put_resolveExternals( VARIANT_FALSE );
			pXSLDoc->put_resolveExternals( VARIANT_FALSE );

			// load DOM document from url/file (MAX_PATH limited)
			hr = pXMLDoc->load( CComVariant( &fileNameIn[0] ), &fLoaded );

			if( FAILED( hr ) || fLoaded == VARIANT_FALSE )
			{
				// load the xml file data by ourselves to bypass MAX_PATH limit
				std::wstring xmlData;
				if( loadFileData( fileNameIn, xmlData ) )
				{
					// load the xml data from BSTR
					hr = pXMLDoc->loadXML( &xmlData[0], &fLoaded );
				}
				else
				{
					DWORD errorId = GetLastError();
					_errorMessage = SysUtils::getErrorMessage( errorId );

					return false;
				}
			}

			if( SUCCEEDED( hr ) && fLoaded == VARIANT_TRUE )
			{
				auto prefix = XmlUtils::getPrefix( pXMLDoc );
				auto nslist = XmlUtils::getNamespaces( pXMLDoc );
				auto title = XmlUtils::getElementText( pXMLDoc, L"/FictionBook/description/title-info/book-title" );

				std::wstring fb_ns = FB20NS;

				if( !prefix.empty() )
				{
					// TODO:
					//fb_ns = nslist[prefix];
				}

				std::map<std::wstring, std::wstring> NAMESPACES {
					{ L"f", fb_ns },
					{ L"l" , XLINKNS }
				};

				// decompress 'fb2.xsl' data
				std::wstring xslData = decompressXslData();

				if( !xslData.empty() )
				{
					size_t off = xslData.find( L"__FB_NS__" );
					xslData.replace( off, 9, fb_ns ); // replace namespace template
				}
				else
					_errorMessage = L"Unable to decompress XSL data.";

				// load the XSL transformation data
				hr = pXSLDoc->loadXML( reinterpret_cast<BSTR>( &xslData[0] ), &fLoaded );

				if( SUCCEEDED( hr ) && fLoaded == VARIANT_TRUE )
				{
					auto outPath = PathUtils::addDelimiter( PathUtils::stripFileName( fileNameOut ) );
					auto files = extractBinaryContent( pXMLDoc, outPath );

					// perform the XSL transformation
					CComBSTR outputHtml;
					hr = pXMLDoc->transformNode( pXSLDoc, &outputHtml );

					if( SUCCEEDED( hr ) && outputHtml )
					{
						// fix image links
						/*CComPtr<IXMLDOMNodeList> pNodesList;
						pXMLDoc->selectNodes( L"//img[@src]", &pNodesList );

						long len = 0;
						pNodesList->get_length( &len );

						for( long i = 0; i < len; i++ )
						{
							CComPtr<IXMLDOMNode> pNode;
							if( SUCCEEDED( pNodesList->get_item( i, &pNode ) && pNode ) )
							{
								// TODO: test and finish this
								auto val = XmlUtils::getNodeAttrValue( pNode, L"src" );
								XmlUtils::setNodeAttrValue( pNode, L"src", &files[val][0] );
							}
						}*/

						FsUtils::saveFileUtf16( fileNameOut, outputHtml.m_str, outputHtml.Length() );
					}
					else
						_errorMessage = XmlUtils::getParserError( pXMLDoc );
				}

				return SUCCEEDED( hr );
			}
			else
				_errorMessage = XmlUtils::getParserError( pXMLDoc );
		}

		return false;
	}

	bool CFictionBook2DataProvider::_readDataCore()
	{
		ShellUtils::CComInitializer _com;

		std::wstring outDirName = FCS::inst().getTempPath() + L"fb2\\";
		FsUtils::makeDirectory( outDirName );
		std::wstring outFileName = outDirName + PathUtils::stripPath( _fileName );
		_result = PathUtils::stripFileExtension( outFileName ) + L".html";

		// convert .fb2 to .html
		return fb2html( _fileName.c_str(), _result.c_str() );
	}
}
